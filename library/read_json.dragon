[
    Compile
]
[ master type ]
!tools.json
(
    [ translated data ]
    nodes !dragon.cell [ type TODO ]
)

[ translation data ]
!tools.json.workspace
(
    [ defines ]
    lexling.types !tools.json.lexling.types,
    parsling.types !tools.json.parsling.types,

    [ error data ]
    error !tools.error,

    [ lexing data ]
    current_character !dragon.current,
    lexlings !tools.json.lexlings,

    [ parsing data ]
    current_lexling !dragon.current,
    parslings !tools.json.parslings
)

[ compile ]
tools.json.compile(text !dragon.buffer, verbose !dragon.cell)(error !tools.error) = {
    [ setup json ]
    dragon.pack.null()(json !tools.json)

    [ setup workspace ]
    dragon.pack.null()(workspace !tools.json.workspace)
    dragon.pack(text, text:start)(workspace:current_character !dragon.current)
    tools.json.lexling.types.setup()(workspace:lexling.types)

    [ lex ]
    tools.json.compile.lex(json, workspace)(json, workspace)
    @verbose.lexlings verbose = {
        tools.json.compile.lex.print(workspace)()
    }

    [ parse ]
    tools.json.compile.parse(workspace)(workspace)
    @verbose.parslings verbose = {
        [ tools.json.compile.parse.print(workspace)() ]
    }

    [ exit compilation ]
    @compilation.exit

    [ setup output ]
    dragon.copy(workspace:error)(error)
}

[ setup error for json reader ]
tools.json.compile.raise_error(workspace !tools.json.workspace, message !dragon.buffer)(workspace !tools.json.workspace) = {
    [ setup strings ]
    dragon.set("%22;error%22;: {%0A;%09;%22;occured%22;: true,%0A;%09;%22;message%22;: %22;")(header)
    dragon.set("%22;%0A;}%0A;")(footer)

    [ open list ]
    dragon.set(dragon.integer.1024)(increase)
    dragon.copy(dragon.true)(workspace:error:occured)
    dragon.list.open(increase)(workspace:error:json)

    [ create error json ]
    dragon.list.append.buffer(workspace:error:json, header)() [ append header ]
    dragon.list.append.buffer(workspace:error:json, message)() [ append message ]
    dragon.list.append.buffer(workspace:error:json, footer)() [ append footer ]
}



[
    Lexing
]
[ lexlings type ]
!tools.json.lexlings
(
    list !dragon.list [ !tools.json.lexling ]
)

[ open lexlings ]
tools.json.lexlings.open()(lexlings !tools.json.lexlings) = {
    [ create dummy lexling ]
    dragon.pack.null()(lexling.dummy !tools.json.lexling)

    [ calculate current ]
    dragon.set(dragon.integer.1024)(increase)
    dragon.structure.byte_size(lexling.dummy)(lexling.size)
    dragon.integer.multiply(increase, lexling.size)(increase)

    [ open list ]
    dragon.list.open(increase)(lexlings:list)
}

[ close lexlings ]
tools.json.lexlings.close(lexlings !tools.json.lexlings)() = {
    [ close list ]
    dragon.list.close(lexlings:list)()
}

[ print lexlings ]
tools.json.lexlings.print(lexlings !tools.json.lexlings)() = {
    [ TODO ]
}

[ lexling type ]
!tools.json.lexling
(
    raw !dragon.buffer,
    type !dragon.cell,
    location !tools.text.location
)

[ print lexling ]
tools.json.lexling.print(lexling !tools.json.lexling)() = {
    [ setup strings ]
    dragon.set("[ ")(header)
    dragon.set(", ")(separator)
    dragon.set(" ]")(footer)

    [ print data ]
    dragon.print.buffer_as_string(header)()
    dragon.print.debug_cell(lexling:type)()
    dragon.print.buffer_as_string(separator)()
    dragon.print.buffer_as_string(lexling:raw)()
    dragon.print.buffer_as_string(footer)()
}

[ lexling location ]
!tools.text.location
(
    file_index !dragon.cell,
    line_index !dragon.cell,
    character_index !dragon.cell
)

[ lexling type structure ]
!tools.json.lexling.types
(
    invalid !dragon.cell,
    left_square_bracket !dragon.cell,
    right_square_bracket !dragon.cell,
    left_curly_bracket !dragon.cell,
    right_curly_bracket !dragon.cell,
    string !dragon.cell,
    integer !dragon.cell,
    comma !dragon.cell,
    colon !dragon.cell,
    name !dragon.cell,
    end_of_file !dragon.cell
)

[ setup json lexling type structure ]
tools.json.lexling.types.setup()(types !tools.json.lexling.types) = {
    [ set values ]
    dragon.set(dragon.integer.0)(types:invalid)
    dragon.set(dragon.integer.1)(types:left_square_bracket)
    dragon.set(dragon.integer.2)(types:right_square_bracket)
    dragon.set(dragon.integer.3)(types:left_curly_bracket)
    dragon.set(dragon.integer.4)(types:right_curly_bracket)
    dragon.set(dragon.integer.5)(types:string)
    dragon.set(dragon.integer.6)(types:integer)
    dragon.set(dragon.integer.7)(types:comma)
    dragon.set(dragon.integer.8)(types:colon)
    dragon.set(dragon.integer.9)(types:name)
    dragon.set(dragon.integer.10)(types:end_of_file)
}

[ lex json ]
tools.json.compile.lex(json !tools.json, workspace !tools.json.workspace)(json !tools.json, workspace !tools.json.workspace) = {
    [ setup data ]
    dragon.set(dragon.integer.32)(whitespace.range.end)
    dragon.pack(dragon.constant.0, whitespace.range.end)(whitespace !dragon.buffer)
    dragon.set(dragon.hexadecimal.7B)(left_curly_bracket)
    dragon.set(dragon.hexadecimal.7D)(right_curly_bracket)
    dragon.set(dragon.hexadecimal.5B)(left_square_bracket)
    dragon.set(dragon.hexadecimal.5D)(right_square_bracket)
    dragon.set(dragon.hexadecimal.22)(double_quote)
    dragon.set(dragon.hexadecimal.2C)(comma)
    dragon.set(dragon.hexadecimal.3A)(colon)
    dragon.set(dragon.hexadecimal.30)(decimal_digits.start)
    dragon.set(dragon.hexadecimal.39)(decimal_digits.end)
    dragon.pack.null()(null_location !tools.text.location)

    [ open lexlings ]
    tools.json.lexlings.open()(workspace:lexlings)

    [ setup loop start ]
    @lexing.loop.start

    [ check if current is in range ]
    dragon.current.within_range(workspace:current_character, dragon.always)(should_quit)
    dragon.jump(should_quit, @lexing.loop.exit)()

    [ get character ]
    dragon.address_to_cell(workspace:current_character:progress, dragon.ascii_character.byte_size)(character, advancement)

    [ if whitespace, go back to beginning of loop ]
    dragon.integer.within_range(whitespace:start, character, whitespace:end, dragon.never)(whitespace_detected)
    @whitespace whitespace_detected = {
        [ next character ]
        dragon.copy(advancement)(workspace:current_character:progress)

        [ jump ]
        dragon.jump(whitespace_detected, @lexing.loop.start)()
    }

    [ otherwise, detect lexling ]
    [ detect left_curly_bracket ]
    dragon.integer.within_range(left_curly_bracket, character, left_curly_bracket, dragon.never)(detected)
    @check.left_curly_bracket detected = {
        [ create lexling ]
        dragon.pack(workspace:current_character:progress, workspace:current_character:progress)(text !dragon.buffer)
        dragon.pack(text, workspace:lexling.types:left_curly_bracket, null_location)(lexling !tools.json.lexling)

        [ next character ]
        dragon.copy(advancement)(workspace:current_character:progress)

        [ append lexling ]
        dragon.list.append.structure(workspace:lexlings:list, lexling)()

        [ jump to loop start ]
        dragon.jump(dragon.always, @lexing.loop.start)()
    }

    [ detect right_curly_bracket ]
    dragon.integer.within_range(right_curly_bracket, character, right_curly_bracket, dragon.never)(detected)
    @check.right_curly_bracket detected = {
        [ create lexling ]
        dragon.pack(workspace:current_character:progress, workspace:current_character:progress)(text !dragon.buffer)
        dragon.pack(text, workspace:lexling.types:right_curly_bracket, null_location)(lexling !tools.json.lexling)

        [ next character ]
        dragon.copy(advancement)(workspace:current_character:progress)

        [ append lexling ]
        dragon.list.append.structure(workspace:lexlings:list, lexling)()

        [ jump to loop start ]
        dragon.jump(dragon.always, @lexing.loop.start)()
    }

    [ detect left_square_bracket ]
    dragon.integer.within_range(left_square_bracket, character, left_square_bracket, dragon.never)(detected)
    @check.left_square_bracket detected = {
        [ create lexling ]
        dragon.pack(workspace:current_character:progress, workspace:current_character:progress)(text !dragon.buffer)
        dragon.pack(text, workspace:lexling.types:left_square_bracket, null_location)(lexling !tools.json.lexling)

        [ next character ]
        dragon.copy(advancement)(workspace:current_character:progress)

        [ append lexling ]
        dragon.list.append.structure(workspace:lexlings:list, lexling)()

        [ jump to loop start ]
        dragon.jump(dragon.always, @lexing.loop.start)()
    }

    [ detect right_square_bracket ]
    dragon.integer.within_range(right_square_bracket, character, right_square_bracket, dragon.never)(detected)
    @check.right_square_bracket detected = {
        [ create lexling ]
        dragon.pack(workspace:current_character:progress, workspace:current_character:progress)(text !dragon.buffer)
        dragon.pack(text, workspace:lexling.types:right_square_bracket, null_location)(lexling !tools.json.lexling)

        [ next character ]
        dragon.copy(advancement)(workspace:current_character:progress)

        [ append lexling ]
        dragon.list.append.structure(workspace:lexlings:list, lexling)()

        [ jump to loop start ]
        dragon.jump(dragon.always, @lexing.loop.start)()
    }
    
    [ detect comma ]
    dragon.integer.within_range(comma, character, comma, dragon.never)(detected)
    @check.comma detected = {
        [ create lexling ]
        dragon.pack(workspace:current_character:progress, workspace:current_character:progress)(text !dragon.buffer)
        dragon.pack(text, workspace:lexling.types:comma, null_location)(lexling !tools.json.lexling)

        [ next character ]
        dragon.copy(advancement)(workspace:current_character:progress)

        [ append lexling ]
        dragon.list.append.structure(workspace:lexlings:list, lexling)()

        [ jump to loop start ]
        dragon.jump(dragon.always, @lexing.loop.start)()
    }
    
    [ detect colon ]
    dragon.integer.within_range(colon, character, colon, dragon.never)(detected)
    @check.colon detected = {
        [ create lexling ]
        dragon.pack(workspace:current_character:progress, workspace:current_character:progress)(text !dragon.buffer)
        dragon.pack(text, workspace:lexling.types:colon, null_location)(lexling !tools.json.lexling)

        [ next character ]
        dragon.copy(advancement)(workspace:current_character:progress)

        [ append lexling ]
        dragon.list.append.structure(workspace:lexlings:list, lexling)()

        [ jump to loop start ]
        dragon.jump(dragon.always, @lexing.loop.start)()
    }

    [ detect string ]
    dragon.integer.within_range(double_quote, character, double_quote, dragon.never)(detected)
    @check.double_quote detected = {
        [ setup lexling start ]
        dragon.copy(workspace:current_character:progress)(text.start)

        [ advance progress past starting quote ]
        dragon.copy(advancement)(workspace:current_character:progress)

        [ setup search for double quote loop ]
        @string.loop.start

        [ check for end of characters ]
        dragon.current.within_range(workspace:current_character, dragon.always)(ran_out_of_characters)
        @string.ran_out_of_characters ran_out_of_characters = {
            [ setup error ]
            dragon.set("Lexing Error: A string ran out of characters.")(error_message)
            tools.json.compile.raise_error(workspace, error_message)(workspace)

            [ exit loop ]
            dragon.jump(dragon.always, @lexing.loop.exit)()
        }

        [ check for ending quote ]
        dragon.address_to_cell(workspace:current_character:progress, dragon.ascii_character.byte_size)(character, advancement)
        dragon.integer.within_range(double_quote, character, double_quote, dragon.never)(detected)
        @check.string.end_quote detected = {
            [ setup lexling ]
            dragon.copy(workspace:current_character:progress)(text.end)
            dragon.pack(text.start, text.end)(text !dragon.buffer)
            dragon.pack(text, workspace:lexling.types:string, null_location)(lexling !tools.json.lexling)

            [ next character ]
            dragon.copy(advancement)(workspace:current_character:progress)

            [ append lexling ]
            dragon.list.append.structure(workspace:lexlings:list, lexling)()

            [ jump to loop start ]
            dragon.jump(dragon.always, @lexing.loop.start)()
        }

        [ not detected, go to loop start to check next character ]
        dragon.copy(advancement)(workspace:current_character:progress)
        dragon.jump(dragon.always, @string.loop.start)()
    }

    [ detect integer ]
    dragon.integer.within_range(decimal_digits.start, character, decimal_digits.end, dragon.never)(detected)
    @check.decimal_digit detected = {
        [ setup lexling start ]
        dragon.copy(workspace:current_character:progress)(text.start)

        [ advance progress past starting digit ]
        dragon.copy(advancement)(workspace:current_character:progress)

        [ setup search for decimal digits loop ]
        @decimal_digit.loop.start

        [ check for end of characters ]
        dragon.current.within_range(workspace:current_character, dragon.always)(ran_out_of_characters)
        @decimal_digit.ran_out_of_characters ran_out_of_characters = {
            [ exit loop ]
            dragon.jump(dragon.always, @lexing.decimal_digit.finished)()
        }

        [ check for next character ]
        dragon.address_to_cell(workspace:current_character:progress, dragon.ascii_character.byte_size)(character, advancement)
        dragon.integer.within_range(decimal_digits.start, character, decimal_digits.end, dragon.never)(detected)
        @decimal_digits.next_character detected = {
            [ next character ]
            dragon.copy(advancement)(workspace:current_character:progress)

            [ jump to loop start ]
            dragon.jump(dragon.always, @decimal_digit.loop.start)()
        }

        [ no more characters detected ]
        [ setup offset ]
        @lexing.decimal_digit.finished

        [ setup lexling ]
        dragon.integer.subtract(workspace:current_character:progress, dragon.constant.1)(text.end)
        dragon.pack(text.start, text.end)(text !dragon.buffer)
        dragon.pack(text, workspace:lexling.types:integer, null_location)(lexling !tools.json.lexling)

        [ append lexling ]
        dragon.list.append.structure(workspace:lexlings:list, lexling)()

        [ jump to start of lexing loop ]
        dragon.jump(dragon.always, @lexing.loop.start)()
    }

    [ detect name ]
    tools.json.compile.lex.check_for_name_character(character)(detected)
    @check.name detected = {
        [ setup lexling start ]
        dragon.copy(workspace:current_character:progress)(text.start)

        [ advance progress past starting character ]
        dragon.copy(advancement)(workspace:current_character:progress)

        [ setup search for characters loop ]
        @name.loop.start

        [ check for end of characters ]
        dragon.current.within_range(workspace:current_character, dragon.always)(ran_out_of_characters)
        @name.ran_out_of_characters ran_out_of_characters = {
            [ exit loop ]
            dragon.jump(dragon.always, @lexing.name.finished)()
        }

        [ check for next character ]
        dragon.address_to_cell(workspace:current_character:progress, dragon.ascii_character.byte_size)(character, advancement)
        tools.json.compile.lex.check_for_name_character(character)(detected)
        @name.next_character detected = {
            [ next character ]
            dragon.copy(advancement)(workspace:current_character:progress)

            [ jump to loop start ]
            dragon.jump(dragon.always, @name.loop.start)()
        }

        [ @oof detected = {} ]

        [ no more characters detected ]
        [ setup offset ]
        @lexing.name.finished

        [ setup lexling ]
        dragon.integer.subtract(workspace:current_character:progress, dragon.constant.1)(text.end)
        dragon.pack(text.start, text.end)(text !dragon.buffer)
        dragon.pack(text, workspace:lexling.types:name, null_location)(lexling !tools.json.lexling)

        [ append lexling ]
        dragon.list.append.structure(workspace:lexlings:list, lexling)()

        [ jump to start of lexing loop ]
        dragon.jump(dragon.always, @lexing.loop.start)()
    }

    [ if nothing was matched, set error ]
    dragon.set("Lexing Error: No lexling was matched.")(error_message)
    tools.json.compile.raise_error(workspace, error_message)(workspace)

    [ setup lexing loop end ]
    @lexing.loop.exit

    [ setup end of file lexling ]
    dragon.set("[end_of_file]")(end_of_file_message)
    dragon.pack(end_of_file_message, workspace:lexling.types:end_of_file, null_location)(lexling !tools.json.lexling)
    dragon.list.append.structure(workspace:lexlings:list, lexling)()
}

[ detect and get name character ]
tools.json.compile.lex.check_for_name_character(character !dragon.cell)(valid !dragon.cell) = {
    [ setup name ranges ]
    dragon.set(dragon.hexadecimal.41)(uppercase_start)
    dragon.set(dragon.hexadecimal.5A)(uppercase_end)
    dragon.set(dragon.hexadecimal.61)(lowercase_start)
    dragon.set(dragon.hexadecimal.7A)(lowercase_end)
    dragon.set(dragon.hexadecimal.30)(numbers_start)
    dragon.set(dragon.hexadecimal.39)(numbers_end)
    dragon.set(dragon.hexadecimal.5F)(underscore)

    [ check ranges ]
    [ check uppercase ]
    dragon.integer.within_range(uppercase_start, character, uppercase_end, dragon.never)(valid)
    dragon.jump(valid, @exit)()

    [ check lowercase ]
    dragon.integer.within_range(lowercase_start, character, lowercase_end, dragon.never)(valid)
    dragon.jump(valid, @exit)()

    [ check numbers ]
    dragon.integer.within_range(numbers_start, character, numbers_end, dragon.never)(valid)
    dragon.jump(valid, @exit)()

    [ check underscore ]
    dragon.integer.within_range(underscore, character, underscore, dragon.never)(valid)
    dragon.jump(valid, @exit)()

    [ not found ]
    dragon.copy(dragon.false)(valid)

    [ exit ]
    @exit
}

[ print lexling list ]
tools.json.compile.lex.print(workspace !tools.json.workspace)() = {
    [ setup variables ]
    dragon.pack.null()(lexling.dummy !tools.json.lexling)
    dragon.structure.byte_size(lexling.dummy)(lexling.size)

    [ setup current ]
    dragon.list.calculate.content_buffer(workspace:lexlings:list)(content)
    dragon.pack(content, content:start)(current !dragon.current)

    [ setup loop start ]
    @loop_start

    [ check for end of current ]
    dragon.current.within_range(current, dragon.always)(should_quit)
    dragon.jump(should_quit, @loop_exit)()

    [ get lexling ]
    dragon.buffer.calculate.end_address(current:progress, lexling.size)(structure.end)
    dragon.pack(current:progress, structure.end)(lexling_source !dragon.buffer)
    dragon.buffer_to_structure(lexling_source)(lexling !tools.json.lexling)

    [ next lexling ]
    dragon.integer.add(current:progress, lexling.size)(current:progress)

    [ print lexling ]
    tools.json.lexling.print(lexling)()
    dragon.print.new_line()()

    [ jump to start of loop ]
    dragon.jump(dragon.always, @loop_start)()

    [ setup loop end ]
    @loop_exit
}



[
    Parsing
]
[ parslings ]
!tools.json.parslings
(
    root !tools.json.parsling
)

[ parsling ]
!tools.json.parsling
(
    type !dragon.cell,
    name !tools.json.lexling,
    value.datum !tools.json.lexling,
    value.members !dragon.list [ !tools.json.parsling ]
)

[ parsling types ]
!tools.json.parsling.types
(
    object !dragon.cell,
    array !dragon.cell,
    string !dragon.cell,
    integer !dragon.cell,
    boolean_false !dragon.cell,
    boolean_true !dragon.cell,
    null !dragon.cell
)

[ setup parsling types ]
tools.json.parsling.types.setup()(types !tools.json.parsling.types) = {
    [ setup data ]
    dragon.set(dragon.integer.0)(types:object)
    dragon.set(dragon.integer.1)(types:array)
    dragon.set(dragon.integer.2)(types:string)
    dragon.set(dragon.integer.3)(types:integer)
    dragon.set(dragon.integer.4)(types:boolean_false)
    dragon.set(dragon.integer.5)(types:boolean_true)
    dragon.set(dragon.integer.6)(types:null)
}

[ parse json lexlings ]
tools.json.compile.parse(workspace !tools.json.workspace)(workspace !tools.json.workspace) = {
    [ setup current ]
    dragon.list.calculate.content_buffer(workspace:lexlings:list)(lexlings_buffer)
    dragon.pack(lexlings_buffer, lexlings_buffer:start)(workspace:current_lexling !dragon.current)

    [ parse ]
    tools.json.compile.parse.object_body(workspace)(workspace, workspace:parslings:root)

    [ consolidate all objects into one buffer ]
    [ TODO ]
}

[ parse object ]
tools.json.compile.parse.object_body(workspace !tools.json.workspace)(workspace !tools.json.workspace, parsling !tools.json.parsling) = {
    [ setup strings ]
    dragon.set("true")(string.true)
    dragon.set("false")(string.false)
    dragon.set("null")(string.null)

    [ setup type ]
    dragon.copy(workspace:parsling.types:object)(parsling:type)

    [ parse contents ]
    [ check for opener ]
    tools.json.compile.parse.check_current_lexling.by_type(workspace, workspace:lexling.types:left_curly_bracket, dragon.true)(workspace, recent_lexling, valid)
    dragon.bits.xor(valid, dragon.constant.1)(invalid)
    @missing_opener invalid = {
        [ setup error ]
        dragon.set("Parsing Error: An object did not start with an opening left curly bracket.")(error_message)
        tools.json.compile.raise_error(workspace, error_message)(workspace)

        [ exit function ]
        dragon.jump(dragon.always, @exit)()
    }

    [ allocate members list ]
    dragon.pack.null()(dummy_parsling !tools.json.parsling)
    dragon.structure.byte_size(dummy_parsling)(parsling.size)
    dragon.integer.multiply(parsling.size, dragon.constant.64)(increase)
    dragon.list.open(increase)(parsling:value.members)

    [ setup member index ]
    dragon.copy(dragon.constant.0)(member_index)

    [ get members ]
    [ setup loop offset ]
    @check_for_members.loop_start

    [ check for closing right curly bracket ]
    tools.json.compile.parse.check_current_lexling.by_type(workspace, workspace:lexling.types:right_curly_bracket, dragon.false)(workspace, recent_lexling, valid)
    dragon.jump(valid, @check_for_members.loop_exit)()

    [ check for comma ]
    dragon.integer.within_range(dragon.constant.0, member_index, dragon.constant.0, dragon.always)(comma_required)
    @comma_required comma_required = {
        [ check for comma ]
        tools.json.compile.parse.check_current_lexling.by_type(workspace, workspace:lexling.types:comma, dragon.true)(workspace, recent_lexling, valid)
        dragon.bits.xor(valid, dragon.constant.1)(invalid)
        @missing_comma invalid = {
            [ setup error ]
            dragon.set("Parsing Error: When searching for the members of a json object, a comma was missing.")(error_message)
            tools.json.compile.raise_error(workspace, error_message)(workspace)

            [ exit function ]
            dragon.jump(dragon.always, @exit)()
        }
    }

    [ check for name string ]
    tools.json.compile.parse.check_current_lexling.by_type(workspace, workspace:lexling.types:string, dragon.true)(workspace, recent_lexling, valid)
    dragon.bits.xor(valid, dragon.constant.1)(invalid)
    @missing_name invalid = {
        [ setup error ]
        dragon.set("Parsing Error: When searching for the members of a json object, an invalid lexling was detected.")(error_message)
        tools.json.compile.raise_error(workspace, error_message)(workspace)

        [ exit function ]
        dragon.jump(dragon.always, @exit)()
    }

    [ setup name ]
    dragon.copy(recent_lexling)(parsling:name)

    [ next index ]
    dragon.integer.add(member_index, dragon.constant.1)(member_index)

    [ check for colon ]
    tools.json.compile.parse.check_current_lexling.by_type(workspace, workspace:lexling.types:colon, dragon.true)(workspace, recent_lexling, valid)
    dragon.bits.xor(valid, dragon.constant.1)(invalid)
    @missing_colon invalid = {
        [ setup error ]
        dragon.set("Parsing Error: When searching for the colon of a json member, an invalid lexling was detected.")(error_message)
        tools.json.compile.raise_error(workspace, error_message)(workspace)

        [ exit function ]
        dragon.jump(dragon.always, @exit)()
    }

    [ detect type ]
    [ detect object ]
    tools.json.compile.parse.check_current_lexling.by_type(workspace, workspace:lexling.types:left_curly_bracket, dragon.false)(workspace, recent_lexling, valid)
    @found_new_object valid = {
        [ parse sub-object ]
        tools.json.compile.parse.object_body(workspace)(workspace, temp_parsling)

        [ check for error ]
        dragon.jump(workspace:error:occured, @exit)()

        [ append object ]
        dragon.list.append.structure(parsling:value.members, temp_parsling)()

        [ next iteration ]
        dragon.jump(dragon.always, @check_for_members.loop_start)()
    }

    [ detect number ]
    tools.json.compile.parse.check_current_lexling.by_type(workspace, workspace:lexling.types:integer, dragon.true)(workspace, recent_lexling, valid)
    @found_new_number valid = {
        [ setup type ]
        dragon.copy(workspace:parsling.types:integer)(parsling:type)

        [ setup number ]
        dragon.copy(recent_lexling)(parsling:value.datum)

        [ next iteration ]
        dragon.jump(dragon.always, @check_for_members.loop_start)()
    }

    [ detect string ]
    tools.json.compile.parse.check_current_lexling.by_type(workspace, workspace:lexling.types:string, dragon.true)(workspace, recent_lexling, valid)
    @found_new_string valid = {
        [ setup type ]
        dragon.copy(workspace:parsling.types:string)(parsling:type)

        [ setup string ]
        dragon.copy(recent_lexling)(parsling:value.datum)

        [ next iteration ]
        dragon.jump(dragon.always, @check_for_members.loop_start)()
    }

    [ detect boolean true ]
    tools.json.compile.parse.check_current_lexling.by_value(workspace, string.true, dragon.true)(workspace, recent_lexling, valid)
    @found_new_boolean_true valid = {
        [ setup type ]
        dragon.copy(workspace:parsling.types:boolean_true)(parsling:type)

        [ setup data ]
        dragon.copy(recent_lexling)(parsling:value.datum)

        [ next iteration ]
        dragon.jump(dragon.always, @check_for_members.loop_start)()
    }

    [ detect boolean false ]
    tools.json.compile.parse.check_current_lexling.by_value(workspace, string.false, dragon.true)(workspace, recent_lexling, valid)
    @found_new_boolean_false valid = {
        [ setup type ]
        dragon.copy(workspace:parsling.types:boolean_false)(parsling:type)

        [ setup data ]
        dragon.copy(recent_lexling)(parsling:value.datum)

        [ next iteration ]
        dragon.jump(dragon.always, @check_for_members.loop_start)()
    }

    [ detect null data ]
    tools.json.compile.parse.check_current_lexling.by_value(workspace, string.null, dragon.true)(workspace, recent_lexling, valid)
    @found_new_null valid = {
        [ setup type ]
        dragon.copy(workspace:parsling.types:null)(parsling:type)

        [ setup data ]
        dragon.copy(recent_lexling)(parsling:value.datum)

        [ next iteration ]
        dragon.jump(dragon.always, @check_for_members.loop_start)()
    }

    [ invalid value lexling ]
    [ raise error ]
    dragon.set("Parsing Error: When breaking down a json object, an unusable lexling was found.")(error_message)
    tools.json.compile.raise_error(workspace, error_message)(workspace)

    [ exit function ]
    dragon.jump(dragon.always, @exit)()

    [ exit loop ]
    @check_for_members.loop_exit

    [ skip past closer ]
    tools.json.compile.parse.check_current_lexling.by_type(workspace, workspace:lexling.types:right_curly_bracket, dragon.true)(workspace, recent_lexling, valid)

    [ exit function ]
    @exit
}

[ check lexling ]
tools.json.compile.parse.check_current_lexling.by_type(workspace !tools.json.workspace, expected_type !dragon.cell, advance !dragon.cell)(workspace !tools.json.workspace, lexling !tools.json.lexling, validity !dragon.cell) = {
    [ check valid lexling ]
    tools.json.compile.parse.retrieve_lexling(workspace)(workspace, lexling, validity)
    dragon.bits.xor(validity, dragon.constant.1)(invalid)
    dragon.jump(invalid, @exit)()

    [ check for lexling type ]
    dragon.integer.within_range(expected_type, lexling:type, expected_type, dragon.never)(validity)
    dragon.bits.xor(validity, dragon.constant.1)(invalid)
    dragon.jump(invalid, @exit)()

    [ advance ]
    tools.json.compile.parse.advance_lexling_current(workspace, advance, dragon.constant.1)(workspace)

    [ exit function ]
    @exit
}

[ check lexling ]
tools.json.compile.parse.check_current_lexling.by_value(workspace !tools.json.workspace, value !dragon.buffer, advance !dragon.cell)(workspace !tools.json.workspace, lexling !tools.json.lexling, validity !dragon.cell) = {
    [ check valid lexling ]
    tools.json.compile.parse.retrieve_lexling(workspace)(workspace, lexling, validity)
    dragon.bits.xor(validity, dragon.constant.1)(invalid)
    dragon.jump(invalid, @exit)()

    [ check for lexling name ]
    tools.check.buffer_contents_are_equal(lexling:raw, value)(validity)
    dragon.bits.xor(validity, dragon.constant.1)(invalid)
    dragon.jump(invalid, @exit)()

    [ set validity ]
    dragon.copy(dragon.true)(validity)

    [ advance ]
    tools.json.compile.parse.advance_lexling_current(workspace, advance, dragon.constant.1)(workspace)

    [ exit function ]
    @exit
}

[ advance lexling ]
tools.json.compile.parse.advance_lexling_current(workspace !tools.json.workspace, advance !dragon.cell, change_by_n_lexlings !dragon.cell)(workspace !tools.json.workspace) = {
    [ if advanceable ]
    @advance advance = {
        [ calculate step ]
        dragon.pack.null()(dummy !tools.json.lexling)
        dragon.structure.byte_size(dummy)(lexling.size)
        dragon.integer.multiply(lexling.size, change_by_n_lexlings)(new_progress)

        [ perform step ]
        dragon.integer.add(workspace:current_lexling:progress, new_progress)(workspace:current_lexling:progress)
    }
}

[ check valid lexling location and retrieve if possible ]
tools.json.compile.parse.retrieve_lexling(workspace !tools.json.workspace)(workspace !tools.json.workspace, lexling !tools.json.lexling, validity !dragon.cell) = {
    [ check for valid lexling range ]
    dragon.current.within_range(workspace:current_lexling, dragon.true)(out_of_range)
    @out_of_range out_of_range = {
        [ set validity ]
        dragon.copy(dragon.false)(validity)

        [ exit function ]
        dragon.jump(dragon.always, @exit)()
    }

    [ setup lexling read buffer ]
    dragon.pack.null()(dummy !tools.json.lexling)
    dragon.structure.byte_size(dummy)(lexling.byte_size)
    dragon.buffer.calculate.end_address(workspace:current_lexling:progress, lexling.byte_size)(lexling.end)
    dragon.pack(workspace:current_lexling:progress, lexling.end)(lexling.source !dragon.buffer)

    [ get lexling ]
    dragon.buffer_to_structure(lexling.source)(lexling !tools.json.lexling)

    [ set validity to true (as far as the lexling location goes) ]
    dragon.copy(dragon.true)(validity)

    [ exit function ]
    @exit
}
